# -*- coding: utf-8 -*-

"""
Static discharge of auditors.
"""

from typhon.nano.scopes import BoundNounsIR
from typhon.objects.auditors import deepFrozenStamp

def dischargeAuditors(ast):
    ast = DischargeDF().visitExpr(ast)
    return ast

# NB: LiveExpr is only introduced here, and not in an earlier pass, out of a
# desire to keep it scoped to where it is necessary. In particular, I would
# like LiveExpr, which is the only expr that can carry a live user-defined
# Monte object, to stay as far away from the initial code loading as possible.
# Please move it to earlier passes as necessary. ~ C.

DeepFrozenIR = BoundNounsIR.extend("DeepFrozen", [],
    {
        "Expr": {
            "LiveExpr": [("obj", None)],
        },
    }
)

deepFrozenOuterNames = {
    # These names are all generated by Typhon.
    u"Any": None, u"Binding": None, u"Bool": None, u"Bytes": None,
    u"Char": None, u"DeepFrozen": None, u"Double": None, u"Infinity": None,
    u"Int": None, u"M": None, u"NaN": None, u"Near": None, u"Ref": None,
    u"Same": None, u"Selfless": None, u"Str": None, u"SubrangeGuard": None,
    u"Void": None, u"_auditedBy": None, u"_equalizer": None, u"_loop": None,
    u"_makeBytes": None, u"_makeDouble": None, u"_makeFinalSlot": None,
    u"_makeInt": None, u"_makeList": None, u"_makeMap": None,
    u"_makeSourceSpan": None, u"_makeStr": None, u"_makeString": None,
    u"_makeVarSlot": None, u"_slotToBinding": None, u"false": None,
    u"null": None, u"throw": None, u"trace": None, u"traceln": None,
    u"true": None,

    # These names are all generated by the prelude.
    u"Empty": None, u"List": None, u"Map": None, u"NullOk": None,
    u"Pair": None, u"Set": None, u"Transparent": None, u"Vow": None,
    u"_accumulateList": None, u"_accumulateMap": None, u"_bind": None,
    u"_booleanFlow": None, u"_comparer": None, u"_iterForever": None,
    u"_makeMessageDesc": None, u"_makeOrderedRegion": None,
    u"_makeOrderedSpace": None, u"_makeParamDesc": None,
    u"_makeProtocolDesc": None, u"_makeVerbFacet": None, u"_mapExtract": None,
    u"_matchSame": None, u"_quasiMatcher": None, u"_splitList": None,
    u"_suchThat": None, u"_switchFailed": None, u"_validateFor": None,
    u"``": None, u"astBuilder": None, u"b``": None, u"eval": None,
    u"m``": None, u"makeBrandPair": None, u"makeLazySlot": None,
    u"promiseAllFulfilled": None, u"safeScope": None,
}

deepFrozenSubsetGuards = {
    # DeepFrozen = DeepFrozen
    u"DeepFrozen": None,

    # null :DeepFrozen -> Void ⊆ DeepFrozen
    u"Void": None,

    # forall x :G, x :DeepFrozen -> G ⊆ DeepFrozen
    u"Bool": None, u"Bytes": None, u"Char": None, u"Double": None,
    u"Int": None, u"Str": None,
}

# NB: The only live exprs possible here are already DF, so we don't need to
# audit them. Revisit this if/when necessary. ~ C.

_DischargeDF = BoundNounsIR.makePassTo(DeepFrozenIR)
class DischargeDF(_DischargeDF):

    def __init__(self):
        self.frameStack = [{}]

    def pushFrame(self):
        self.frameStack.append({})

    def popFrame(self):
        self.frameStack.pop()

    def searchFrames(self, name):
        for frame in reversed(self.frameStack):
            if name in frame:
                return frame[name]
        return False

    def visitMethod(self, method):
        self.pushFrame()
        rv = _DischargeDF.visitMethod(self, method)
        self.popFrame()
        return rv

    def visitMatcher(self, matcher):
        self.pushFrame()
        rv = _DischargeDF.visitMatcher(self, matcher)
        self.popFrame()
        return rv

    def unwrappingGet(self, expr):
        if (isinstance(expr, self.dest.CallExpr) and
                expr.verb == u"get" and
                len(expr.args) == len(expr.namedArgs) == 0):
            # Looks like a slot/binding .get/0 to me!
            return expr.obj
        return expr

    def isDeepFrozenGuard(self, expr):
        # guard.get().get() -> guard.get()
        expr = self.unwrappingGet(expr)

        # guard.get() -> guard
        expr = self.unwrappingGet(expr)

        if isinstance(expr, self.dest.OuterExpr):
            # Certain outer names are known to be unretractable guards for
            # subsets of DeepFrozen.
            return expr.name in deepFrozenSubsetGuards
        else:
            return False

    def visitNounPatt(self, name, guard, index):
        guard = self.visitExpr(guard)
        self.frameStack[-1][name] = self.isDeepFrozenGuard(guard)
        return self.dest.NounPatt(name, guard, index)

    def visitFinalSlotPatt(self, name, guard, index):
        guard = self.visitExpr(guard)
        self.frameStack[-1][name] = self.isDeepFrozenGuard(guard)
        return self.dest.FinalSlotPatt(name, guard, index)

    def visitFinalBindingPatt(self, name, guard, index):
        guard = self.visitExpr(guard)
        self.frameStack[-1][name] = self.isDeepFrozenGuard(guard)
        return self.dest.FinalBindingPatt(name, guard, index)

    def selfNames(self, patt):
        """
        Retrieve the names from this patt which can be used self-referentially
        without invalidating DeepFrozen.
        """

        if (isinstance(patt, self.dest.NounPatt) or
            isinstance(patt, self.dest.FinalSlotPatt) or
            isinstance(patt, self.dest.FinalBindingPatt)):
            return [patt.name]
        else:
            return []

    def auditDeepFrozen(self, patt, layout):
        selfNames = self.selfNames(patt)
        for outerName in layout.outerNames.keys():
            if outerName not in deepFrozenOuterNames:
                return False
        for frameName in layout.frameNames.keys():
            # Check the relatively short list of self-names first.
            if frameName not in selfNames:
                # Now search the rest of the frame.
                if not self.searchFrames(frameName):
                    return False
        return True

    def visitObjectExpr(self, doc, patt, auditors, methods, matchers, mast,
                        layout):
        patt = self.visitPatt(patt)
        auditors = [self.visitExpr(auditor) for auditor in auditors]

        # Search for DeepFrozen. Only outer names can refer to the true
        # DeepFrozen.
        for i, auditor in enumerate(auditors):
            # DeepFrozen.get().get() -> DeepFrozen.get()
            auditor = self.unwrappingGet(auditor)

            # DeepFrozen.get() -> DeepFrozen
            auditor = self.unwrappingGet(auditor)

            if isinstance(auditor, self.dest.OuterExpr):
                if auditor.name == u"DeepFrozen":
                    if self.auditDeepFrozen(patt, layout):
                        # Success!
                        auditors[i] = self.dest.LiveExpr(deepFrozenStamp)
                        # Also let all of our descendants know that we passed.
                        for name in self.selfNames(patt):
                            self.frameStack[-1][name] = True

        methods = [self.visitMethod(method) for method in methods]
        matchers = [self.visitMatcher(matcher) for matcher in matchers]
        return self.dest.ObjectExpr(doc, patt, auditors, methods, matchers,
                                    mast, layout)
        deepFrozenStamp
